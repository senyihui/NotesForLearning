# 1 MySQL构架与历史

* 并发控制
  * 锁粒度
  * 锁策略：在锁的开销和数据的安全性之间寻求平衡
  * 表锁：`MySQL`中最基本的锁策略，也是开销最小
  * 行级锁：只在存储引擎层实现
* 事务
  * ACID:
    * 原子性
    * 一致性
    * 隔离性
    * 持久性
  * 隔离级别
    * 未提交读`READ UMCOMMITED`：脏读
    * 提交读`READ COMMITED`
    * 可重复读`REPEATABLE READ`：默认的事务隔离级别；无法解决幻读
    * 可串行化`SERIALIZABLE`：通过锁
  * 脏读：事务可以读取未提交的数据
  * 幻读
  * 死锁：两个或多个事务在统一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象
  * `MySQL`服务器层不管理事务，事务是由下层的存储引擎实现的
  * `MVCC`(`Multiversion Concurrency Control`)
  * `InnoDB`引擎

# 2 MySQL基准测试

基准测试是针对系统设计的一种压力测试

* 集成式
* 单组件式

测试指标

* 吞吐量：单位时间内的事务处理数  常用单位：每秒事务数（`TPS`）每分钟事务数（`TPM`）
* 响应时间或者延迟
* 并发性：并发性基准测试需要关注的是正在工作中的并发操作，或者是同时工作中的线程数或者连接数
* 可扩展性

基准测试方法

* 设计
* 运行多长时间
* 获取系统性能和状态
* 获取准确的测试结果
* 运行并分析结果
* **绘图的重要性**

基准测试工具

* 集成式测试工具
  * `ab`
  * `http_load`
  * `JMeter`
* 单组件测试工具
  * `mysqlslap`
  * `MySQL Benchmark Suite`
  * `Super Smack`

# 3 服务器性能剖析

## 性能剖析简介

本书：响应时间

性能剖析报告

**无论是外部测量还是猜测，数据都不是百分之百准确的，这就是系统不透明所带来的的风险。**

理解性能剖析

## 对应用程序进行性能剖析

Q：性能剖析本身会导致服务器变慢吗？ page 73

安利了一个软件：`New Relic`

## 剖析MySQL查询

慢查询日志

本书安利工具`pt-query-digest`

`V/M`列提供了方差均值比，也就是常说的离差指数；离差指数高的查询对应的执行时间的变化较大，这类查询往往值得去优化

* 使用`SHOW PROFILE`
  * 首先要`SET profiling = 1`
* 使用`SHOW STATUS`
* `pt-query-digest`提供了字节偏移值，可以直接跳转到细节部分

## 诊断间歇性问题

单条查询问题还是服务器问题？

捕获诊断数据

* 可靠且实时的触发器，也就是区分问题什么时候出现的方法
* 一个收集诊断数据的工具

安利`Percona ToolKit`中的`pt-stalk`

案例分析 page 99

是什么导致了性能低下？

* 资源被过度使用，余量已经不足以正常工作
* 资源没有被正常配置
* 资源已经损坏或者失灵

# 4 Schema与数据类型优化

## 选择优化的数据类型

* 更小的通常更好
* 简单就好
  * 用`MySQL`内建类型来存储日期和时间
  * 用整型存储`IP`地址
* 尽量避免`NULL`

## MySQL Schema 设计中的陷阱

* 太多的列
* 太多的关联
* 全能的枚举
* 变相的枚举

## 范式和反范式

> 基础概念： https://blog.csdn.net/wenco1/article/details/88077279 

## 缓存表和汇总表

* 物化视图：预先计算并且储存在磁盘上的表，可以通过各种各样的策略刷新和更新
* 计数器表

> `ON DUPLICATE KEY UPDATE`:该语句是基于主键（PRIMARY KEY）或唯一索引（UNIQUE INDEX）使用的。
> 如果已存在该唯一标示或主键就更新；如果不存在该唯一标示或主键则作为新行插入。

## 加快`ALTER TABLE`的速度

影子拷贝：用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表

# 5 创建高性能的索引

> `ORM`：对象关系映射

## 索引基础

* B-Tree 索引
  * 适用于全键值、键值范围或键前缀查找
  * 限制
* 哈希索引
  * 无法用于排序
* 空间数据索引
* 全文索引

## 高性能索引策略

==page 153 ~ 182 跳过==

## 索引案例学习

* 支持多个过滤条件
* 避免多个范围条件
  * 范围条件查询和多个等值条件查询
* 优化排序

## 维护索引和表

# 6 查询性能优化

要优化查询，实际上要优化子任务：要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行的更快

## 优化数据访问

每次看到`SELECT *`都要问问自己，这样真的必要吗？

* 响应时间
* 扫描行数与返回行数
* 扫描行数与访问类型
  * **要明白一下是怎么回事**
    * 扫描表
    * 扫描索引
    * 范围访问
    * 单值访问

## 重构查询方式

* 切分查询（分治法）
* 分解关联查询

## 查询执行的基础

1. 客户端发送一条查询给服务器
2. 服务器先检查缓存，如果命中了缓存，则立刻返回储存在缓存中的结果。否则进入下一阶段
3. 服务器进行`SQL`解析、预处理，再由优化器生成对应的执行计划
4. `MySQL`根据优化器生成的执行计划，调用存储引擎的`API`来执行查询
5. 将结果返回给客户端

`MySQL`客户端/服务器之间的通信协议是半双工的

查询状态 page 207

一些能够处理的优化类型 page 211

**MySQL如何关联查询** page 216 图

## 查询优化器的提示

## 优化特定类型的查询

## 案例

* 使用MySQL构建一个队列表
* 计算两点之间的距离
* 使用用户自定义函数

# 7 MySQL高级特性

==跳过==

# 8 优化服务器设置

配置MySQL，应当从理解MySQL内核和行为开始



